C3.5. Контекстные менеджеры. Ключевое слово with, принципы создания 
         собственных контекстных менеджеров.


В этом юните поговорим про контекстные менеджеры и ключевое слово with.

Для чего это всё нужно?

И тут лучше всего начать с уже знакомого вам примера. Допустим, вам надо 
открыть файл и записать в него секретную или не очень информацию. 
Как бы вы это сделали, зная о принципах работы с файлами и про
встроенную функцию open?

Да примерно вот так:

f = open("file.bin", "wt")
f.write("MYSECRETINFO")
f.close()

И это действительно будет работать. А теперь давайте представим, что вы 
забыли закрыть файл и потеряли всю информацию в нём. Это не очень приятно. 
Особенно, если вы писали, например, свою базу данных, и потеряли 
информацию в ней. Но дело даже не в том, что вы могли забыть закрыть 
файл, даже если вы человек-пунктуальность, я бы советовал вам не 
испытывать судьбу. Вы же не станете чинить проводку самостоятельно, 
даже зная закон Ома и налету определяя где «+», а где «-»? Вот и здесь 
так же. Для работы с ресурсами лучше обратиться к специальным 
возможностям языка. Так вы точно не выстрелите себе в ногу, при 
этом добившись такого же результата.

Давайте договоримся о понятии «контекстный менеджер».

Контекстный менеджер — определенная структура в языке Python 
                                            (класс или генератор), основывающаяся на главном 
                                            принципе: при его открытии и закрытии срабатывает 
                                            заранее написанный программистом код.

Открытие происходит при входе в блок с помощью ключевого слова with. 
Закрытие происходит, когда блок заканчивается. Например, на 
входе — открывается файл, на выходе — закрывается.

Ну и самый простой пример использования контекстного менеджера с 
использованием ключевого слова with с файлами:

with open("file.bin", "wt") as f: # открываем файл с помощью with
    f.write("abcdefg")

В этом примере мы открываем файл с помощью контекстного менеджера, 
который автоматически закроет его за нас. Почему бы просто не закрыть 
файл методом .close(). Дело в том, что на выходе из контекстного менеджера 
может понадобится выполнить не один десяток операций, в том числе 
обращений к стороннему API или базе данных. Не станете же вы каждый 
раз писать один и тот же код? И даже если вы напишите функцию или метод, 
делающий это за вас, его опять надо не забыть вызвать, иначе всё будет 
напрасно. Конечно же в этом случае нам легче просто написать контекстный 
менеджер и вызывать его каждый раз, когда мы хотим, чтобы он выполнил 
всю грязную работу за нас.

Пишутся контекстные менеджеры очень легко. Ведь, по сути, это всего-то 
по-особенному устроенные классы.

Чтобы написать контекстный менеджер нужно всего лишь помнить о 
нескольких вещах:

 1. Нужно создать класс и написать в нём метод __enter__. 
     Код в этом методе будет выполняться при входе в контекстный менеджер
     (при создании объекта с ключевым словом with).

 2. Написать метод __exit__. Этот метод будет выполнять код, помещённый 
    в него, на выходе.

 3. Добавить в этот метод три дополнительных аргумента помимо 
     self — exc_type, exc_val, exc_tb. Зачем они нужны, расскажу чуть позже.

Ну а сейчас давайте попробуем написать простенький измеритель времени
исполнения нашего кода:

from datetime import datetime
import time # проверять действие измерителя будем с помощью библиотеки time
 
 
# вся суть этого измерителя заключается в том, что мы считаем разницу в секундах между открытием и закрытием контекстного менеджера
class Timer:
    def __init__(self): 
            pass
 
    def __enter__(self): # этот метод вызывается при запуске с помощью with. Если вы хотите вернуть какой-то объект, чтобы потом работать с ним в контекстном менеджере, как в примере с файлом, то просто верните этот объект через return
            self.start = datetime.utcnow()
            return None
    
    def __exit__(self, exc_type, exc_val, exc_tb): # этот метод срабатывает при выходе из контекстного менеджера
            print(f"Time passed: {(datetime.utcnow() - self.start).total_seconds()}")
 
 
with Timer():
    time.sleep(2)  # засыпаем на 2 секунды

# В консоль должно вывестись примерно следующее:

# Time passed: 2.00099

В дополнение к комментариям в коде ещё хотелось бы сказать пару слов 
об аргументах метода __exit__.

О каждом из них по порядку:

 * exc_type — это тип исключения, из-за которого вылетел контекстный менеджер. 
    Если всё прошло успешно, то значение этого аргумента будет None.

 * exc_val — сообщение в исключении. Аналогично: если всё прошло успешно, 
    этот аргумент будет None.

 * exc_tb — объект сообщения от интерпретатора. Лучшего его вообще не 
    трогать, если вы не разработчик языка, но тем не менее он всегда ждёт 
    вас здесь. Возможно когда-то, после нашего курса вы…

Как можно было догадаться, Python был бы не Python, если бы у него не было 
библиотек на любой крайний случай. В далёкой версии Python 2.6 появилась 
возможность создания контекстных менеджеров через генераторы.

Давайте взглянем, как это можно сделать.

Но перед этим хотелось бы разъяснить разницу в реализации. По сути, здесь 
разница только в том, что контекстный менеджер на генераторах — это функция 
(для особо привередливых — генератор). В ней до yield выполняется код, 
который мы могли бы записать в __enter__, если бы делали контекстный 
менеджер в виде класса, а после yield пишем код, который выполнился бы 
в __exit__. То есть до yield — всё что произойдёт при входе, после — всё, 
что на выходе. Вот и вся разница. Как видите, она не велика.

Давайте же теперь посмотрим код:

from datetime import datetime
import time
 
 
from contextlib import contextmanager # импортируем нужный нам декоратор
 
 
@contextmanager # оборачиваем функцию в декоратор contextmanager
def timer():
    start = datetime.utcnow()
    yield # если вам нужно что-то вернуть через контекстный менеджер, просто вставьте этот объект сюда.
    print(f"Time passed: {(datetime.utcnow() - start).total_seconds()}")
 
 
with timer():
    time.sleep(2)

# Результат работы такого контекстного менеджера на основе генераторов 
# абсолютно такой же:

# Time passed: 2.001097

Теперь давайте подведём итоги данного юнита:

 1. Мы узнали, зачем нужен контекстный менеджер и на практике познакомились
     с тем, какой он удобный.

 2. Контекстный менеджер вызывается с помощью ключевого слова with. 
     Он может возвращать или не возвращать объект для работы. Например, 
     если контекстный менеджер подразумевает работу с каким-либо объектом, 
     то надо добавить в запись: as *var*, где var — имя переменной в данном 
     контексте.

 3. Мы научились строить собственные контекстные менеджеры на основе 
     классов. Для этого мы пишем класс со специальными методами 
     def __enter__(self, …) и __exit__(self, exc_type, exc_val, exc_tb). 
     __enter__ вызывается при входе в контекстный менеджер, 
     __exit__ — при выходе (не забудьте добавить необходимые аргументы).

 4. Научились строить контекстные менеджеры на основе генераторов и 
     декоратора contextmanager из библиотеки contextlib.

Если вам осталось что-то не понятно, посмотрите видеоматериал по теме 
в начале юнита . Надеюсь, после него вопросов не останется!

Ну и на этом всё о контекстных менеджерах. Не бойтесь применять их 
в работе, экспериментируйте!

3.5.1

Контекстные менеджеры в Python используются с помощью ключевого слова:
Ответ: with
 

3.5.2

Контекстные менеджеры:

 * могут принимать аргументы

 * могут работать с объектами с помощью синтаксиса: as *имя переменной*. +++

 * обязательно должны работать с каким-либо объектом.


3.5.3

Контекстные менеджеры на основе классов должны реализовывать методы 
(перечислите через запятую с пробелом):
Ответ: __exit__, __enter__
  

3.5.4

Соотнесите 
---------------------------------------------------------------------------------------------------------------
|                      метод __enter__                     |                     метод __exit__                  |
|---------------------------------------------------------|-----------------------------------------------------|
|               Выполняеться на входе                |            Выполняеться на выходе           |
|---------------------------------------------------------|-----------------------------------------------------|
|                                                                     |  Принимает оюезательно 3 аргумента |
---------------------------------------------------------------------------------------------------------------


3.5.5

Контекстный менеджер на основе генераторов:

 * Выполняется быстрее, чем контекстный менеджер на основе классового 
    представления

 * Реализуется с помощью применения декоратора contextmanager к 
    генератору +++

 * Использует return для возвращения объекта для работы

 * Не имеет преимуществ перед классовым представлением. 
   Они одинаково с практической точки зрения +++

 * Экономит память во время работы программы.


3.5.6

Напишите контекстный менеджер, который умеет безопасно работать с файлами.

В конструктор объекта контекстного менеджера передаются два аргумента: 
первый — путь к файлу, который надо открыть, второй — тип 
открываемого файла (для записи, для чтения и т. д.).

При входе в контекстный менеджер должен открываться файл, 
и возвращаться объект для работы с этим файлом.

При выходе из контекстного менеджера файл должен закрываться. 
(Эталоном работы можно считать контекстный менеджер open).

Решение: 

class OpenFile:
    def __init__(self, path, type):
        self.file = open(path, type)
    
    def __enter__(self):
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.file.close()
 
 
with OpenFile('hello.txt', 'wt') as f:
    f.write('Мой контекстный менеджер делает тоже самое!')

3.5.7
Обсудите с коллегами в канале модуля в Slack преимущества использования 
контекстного менеджера. С какими концепциями программирования он хорошо сочетается?

