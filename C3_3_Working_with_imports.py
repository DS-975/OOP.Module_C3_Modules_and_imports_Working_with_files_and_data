C3.3. Работа с импортом

При решении задачи может возникнуть две мысли: либо написать решение 
с нуля, либо воспользоваться уже готовыми решениями и адаптировать 
их под себя. Оба пути имеют место быть. Чаще всего новички пытаются 
писать что-либо самостоятельно, даже не предполагая, что для их задач 
уже есть готовые решения. Во-первых, это занимает много времени, 
во-вторых, вы не всегда сможете написать оптимальное решение, 
которое к тому же может работать неправильно на некоторых тестах.

Когда вы в дальнейшем начнете заниматься серьезными проектами, 
допустим на работе, то следует выбирать правильные инструменты 
для конкретных задач, да плюс ко всему, желательно, чтобы они 
работали без ошибок. Поэтому можно использовать решения, которые 
были написаны профессионалами, ваша задача их правильно применить, 
при этом, не стреляя из пушки по воробьям. Возможно, у вас есть 
какая-то своя заготовка кода, которая решает какую-то локальную 
задачу, которая очень часто повторяется в вашей работе, и чтобы 
снова её не переписывать, вы можете выделить её в отдельную 
программу (модуль) и импортировать один и тот же модуль в нужный
вам момент.

Для чего это нужно:

1. Уменьшить объем кода путем его переиспользования. Исходники хранятся 
    в одном месте, а вы просто их импортируете (подгружаете) и 
    используете функционал данного модуля без переноса самих исходников. 
    Также просто исправлять ошибки. Вам не нужно искать, где 
    использовался этот код. Исправляете в одном месте, в остальных 
    программах после их перезапуска будет обновленная версия.

2. Это способ структурировать ваш код. Плохая структура — много ошибок. 
    Когда всё находится «по своим полочкам», проще отыскать нужный 
    момент, и вы интуитивно будете знать, где его искать. Даже если 
    будете работать с чужим кодом, если он составлен с соблюдением 
    общепринятых рекомендаций. 

3. Использование уже готовых реализаций.

Как импортировать модуль

Импорт происходит с помощью зарезервированного слова import название модуля.

import os
import sys

После импорта модуля в вашей программе становятся доступны все 
возможности импортированного модуля: его глобальные переменные, 
функции и прочее. Например, импортировав модуль os из стандартной 
библиотеки, вы можете узнать текущую директорию и список её файлов. 
Для того, чтобы обратиться к содержимому модуля, нужно после его 
имени поставить точку и указать нужный вам элемент.

import os
 
print(os.getcwd())  # получить текущую директорию
print(os.listdir())  # получить список файлов текущей директории

Если вы работаете в IDE, то после нажатия на точку вам будет предложено, 
что можно вызвать из указанного модуля.

import os

os.# будет список выподающий 

Как узнать, что умеет тот или иной модуль? Если это сторонний модуль, 
который вы скачали с помощью менеджера пакетов, например, pip, или 
он из стандартной библиотеки, то можно найти документацию на него 
в сети интернет, благо Python славится подробной документацией. 
Как быть, если нет доступа в интернет? Для того, чтобы получить 
документацию на тот или иной модуль, можно воспользоваться 
командой help.

import os
help(os)

После этого в консоли будет выведена информация о взаимодействии 
с модулем. Своего рода шпаргалка, заранее составленная разработчиками 
модуля. Если вы не знаете или забыли какой-то функционал модуля - 
можете смело подглядывать туда. В отличии от функции dir здесь 
вы также можете посмотреть и подсказки, а не только атрибуты модуля.

Python очень серьезно относится к качеству кода, поэтому давайте разберем,
как следует импортировать модули. Мы сейчас смотрим не столько на 
синтаксические ошибки, сколько на вопросы связанные со стилем кода 
(см. PEP8). Не следует импортировать модули в одну строку, каждый 
отдельный модуль должен импортироватся на отдельной строке:

# правильно
import os
import sys
 
# неправильно
import os, sys

Но если вы хотите импортировать, например, несколько функций из одного 
модуля, можно перечислить их через запятую:

from subprocess import Popen, PIPE
Также для импорта существует несколько различных способов записи, 
но делают они тоже самое: импорт всего модуля и обращение 
к функции через имя модуля:

import math
print(math.pi)  # 3.141592653589793

Импортируем всё из модуля, это позволяет сократить запись, и обращаться 
к функциям, не указывая имя модуля:

from math import *  # импортируем всё из модуля math
print(pi)  # 3.141592653589793

Даем новое имя модулю, это позволяет избежать ошибок, если у вас есть 
функция, которая называется так же как модуль, то вы можете дать новое 
имя модулю для данного скрипта:

import math as m  # использование нового имени для обращения к импортированному модулю
print(m.pi)  # 3.141592653589793

Даем новое имя функции или переменной, это позволяет избежать ошибок,
если у вас есть одноименная функция в вашей программе, и вы не хотите 
её переименовать:

from math import pi as PI
print(PI)  # 3.141592653589793

Единственно правильного решения нет. Нужно исходить из конкретной 
задачи и того, что используется в коде. Использование новых имен 
позволяет уменьшить размер кода и повысить его читабельность. 
А импорт отдельных элементов позволяет не захламлять возможные 
варианты, которые может выдать IDE.

Как правильно составить модуль?

Для того, чтобы в модулях можно было легко найти нужные строки, 
принято их формировать стандартным образом.

Для этого были сформированы следующие правила.


1. Вся основная логика модуля заключена в отдельные функции или классы. 
    На глобальном уровне могут быть объявлены только константы или 
    необходимые для инициализации модуля операции.

# НЕ ПРАВИЛЬНЫЙ ВАРИАНТ
MAIN_CONSTANT = 3.14159265358
print(MAIN_CONSTANT)

def a(x):
	retyrn x + MAIN_CONSTANT

t = 112
print(a(t))

# ПРАВИЛЬНЫЙ ВАРИАНТ
MAIN_CONSTANT = 3.14159265358

def calc(x):
	retyrn x + MAIN_CONSTANT


    Cверху представлен плохой пример, потому что в нем содержатся лишние
    функции print() в 3 и 11 строках. А также объявлена не константная 
     переменная t, которая проверяет работу функции a в 11 строке. 
     Снизу представлен правильный вариант.

2. Если вы планируете, что модуль могут запускать как самостоятельный 
    скрипт – используйте следующую инструкцию: if __name__ == '__main__':.

    Тогда прошлый пример будет правильно записать в таком формате:

MAIN_CONSTANT = 3.14159265358
print(MAIN_CONSTANT)

def a(x):
	retyrn x + MAIN_CONSTANT

t = 112
print(a(t))


    Как правило, в блок if __name__ == '__main__' заносят все вызовы 
    функций и вывод информации на стандартный поток вывода. 
    Ещё один вариант — создать отдельную main() функцию, переписав 
    в неё всю логику при запуске, и вызывать её в данном блоке.

    Как это работает? Ваш скрипт может выполняться и самостоятельно, 
    а может быть импортирован как модуль другим скриптом. Чтобы 
    выделить код, который не должен выполняться при импорте его 
    следует поместить в условный оператор с условием 
    if __name__ == '__main__':.

    Каждый скрипт при запуске получает от интерпретатора имя, 
    которое хранится в специальной переменной __name__, которая 
    будет равна "__main__", только если файл запускается как 
    основная программа, и выставляется равной имени модуля 
    при импорте модуля. То есть условие if __name__ == '__main__' 
    проверяет, был ли файл запущен напрямую.


3. Хорошая структура модуля выглядит следующим образом:                                                                                                                         

    1. Docstring (описание) модуля.

    2. Область импорта:
        * импорты системных библиотек;
        * импорты стандартных пакетов (из PyPI);
        * импорты ваших модулей (локальных).
     
    3. Область объявление глобальных констант.

    4. Инициализация модуля.

    5. Область определения функций и классов.

    6. Функции.
    7. if __name__ == '__main__' (метод main) по желанию 
       (это одни из немногих нюансов при работе с собственными модулями).


Если же вы хотите более подробно узнать о всех тонкостях импортирования 
из собственных модулей, можете посмотреть скринкаст.

1 """
2 Здесь содержится описание вашего модуля
3 """
4
5 import os
6 import sys
7 
8 import requests
9
10 import my_stack
11 
12 MAIN_CONSTANT = 3.14159265358
13
14
15 def  main():
16 	print(MAIN_CONSTANT)
17 	some_func()
18
19
20 def some_func():
21 	print(help(os))
22 	print(help(sys))
23 	print(help(requests))
24 	print(help(my_stack))
25
26
27 if __name__ == '__naim__':
28 	main()
29

В строках 1-3 представлено описание того, что выполняет модуль, 
так называемый docstring. Строки 5-6 импортируют модули стандартной
 библиотеки. В 8 строке импортируется дополнительная библиотека requests, 
которая была установлена. 10 строка импортирует ваш собственноручно 
написанный модуль. Все три этих блока следует отделять пустой строкой, 
чтобы визуально разделить их.

Далее идет объявление констант — 12 строка. Следом идет инициализация 
модуля, та функция которая содержит код, который будет выполняться 
при непосредственном запуске модуля. Делается это затем, что модуль может 
содержать большое количество вспомогательных функций. И чтобы не 
искать основную логику работы модуля по многочисленным строкам кода 
или прокрутки файла до блока if __name__ == '__main__':, который находиться 
в самом конце, её выносят в отдельную функцию и ставят на первое место. 
На примере это строки 15-17. Далее идет область определения функций, 
классов, которые необходимы для работы с модулями,  — строки 20-24.

И остался блок if __name__ == '__main__':, содержащий код, который не 
должен выполняться при импорте, а только при непосредственном запуске. 
И заканчиваться ваш скрипт должен пустой строкой — строка 29.

Чтобы создать и импортировать собственный модуль, давайте создадим 
два модуля (скрипта). В первом будет объявлена функция, печатающая 
приветственное сообщение «Hello world». А вот вызовем эту функцию 
уже в другом файле, предварительно импортировав её.

Но перед тем, как мы это сделаем, небольшое отступление.

ВАЖНО: Чтобы модули заработали правильно, их нужно хранить в той же 
папке, в которой вы запускаете главный скрипт, иначе Python не найдёт 
ваш модуль!

Если же вы используете чужие библиотеки, скачанные напрямую через 
интернет, то их необходимо скопировать в папку с проектом. Однако, 
как правило, этого не требуется, если вы устанавливаете библиотеки 
через пакетный менеджер PIP. Если вам понравилась какая-то библиотека 
из интернета и вы хотите с ней работать, то просто напишите в терминале 
(на Windows в cmd) следующую строчку:

pip install <имя вашей библиотеки>

и она станет доступна для импорта из любого вашего проекта!

Если вы не знакомы с терминалом, смотрите видеоинструкцию в скринкасте:


Более подробно о работе с библиотеками можно узнать в этом скринкасте:


А теперь давайте вернёмся к нашей задаче:

# function.py

def hello():
    print('Hello world')

# main.py

from function import hello

hello()  # вызвали импортированную функцию

В данном случае у нас есть два файла function.py и main.py. В первом 
объявлена функция, а во втором мы уже непосредственно вызываем 
её выполнение.

Иногда однако может случится такая неприятная штука как кросс-импорт 
или же перекрёстный импорт. В таком случае обычно разбивают файл на 
ещё более мелкие составляющие или всевозможные пакеты. Однако если 
так сделать не получается по каким-либо причинам то помочь может 
шаблон проектирования «Фабрика», который помогает избежать кросс 
импорта даже в самых сложных ситуациях.

О том, как применять его при написании ваших программ, можно посмотреть 
в этом скринкасте.


Если вы хотите импортировать собственные модули в ваших проектах, 
при этом не закидывая их напрямую в папку с ними, или же вы надумали 
писать собственную библиотеку на Python и выложить её на общее 
пользование, то можете ознакомиться с инструкцией по написанию 
собственных библиотек в скринкасте о сложном импорте.

3.3.1

Выберите пункты, правильно описывающие, для чего нужны модули.

* Способ структурирования кода +++

* Повторное использование кода +++

* Увеличение объема кода

* Возможность пользоваться готовыми реализациями +++

* Python не умеет работать с файлами, отличными от эталонной структуры модуля


3.3.2

ЗАДАЧА
Найдите в сторонних источниках информацию о модуле math и соотнесите 
функцию и ее действие.
----------------------------------------------------------------------------------------------------------------
|    math.ceil(X)    |   math.fabs9X)  |   math.floor(X)   |  math.isfinter(X) |   math.sqrt(X)    |
|--------------------- |---------------------|----------------------|----------------------|----------------------|
| округление до  |                         |                           |                          |                          |
|  ближайшего    |      модуль X    |   вокругление    |    является ли   |    квадратный   |
|    большего      |                         |           вниз         |     X числом     |    корень из X   |
|       числа         |                          |                           |                          |                          |
----------------------------------------------------------------------------------------------------------------

3.3.3

Используя модуль math, найдите значение данного выражения:

math.trunc(math.fmod(math.fabs(-10000000), 55)+0.3)

Ответ 10
 
3.3.4

Найдите в сторонних источниках информацию о модуле time и ответьте на вопросы.

* Какая функция позволяет узнать время с начала эпохи, выраженное в секундах? 
   Впишите только название, без скобочек ().
   Ответ: time 

* Какая функция позволяет преобразовать время, выраженное в секундах 
   с начала эпохи в строку вида «Thu Sep 27 16:42:37 2012»? 
   Впишите только название, без скобочек ().
   Ответ: ctime

* Какая функция позволяет приостановить выполнение программы на 
   заданное количество секунд? Впишите только название, без скобочек ().
   Ответ: sleep


3.3.5

Поэкспериментируйте с модулем time. Выведите в консоль текущее время, 
попробуйте вывести следующие данные:

* только время;

* только минуты;

* только дату;

* только месяц.

Если возникнут трудности, пишите менторам!

3.3.6

Программист Вася пытался написать программу, которая запускает таймер 
от 10 до 0 включительно, но что-то пошло не так. Укажите номера строк 
через запятую с пробелам в порядке возрастания, где Вася ошибся.

1 import time
2
3 i = 10 
4 while i !=0:
5 	print(i)
6	sleep(1)
7 	i -=1
8 	print("Время вышло!")

Ответ: 4,6,8
 

3.3.7
Задание на самопроверку.

Вам нужно написать два модуля:

Первый должен содержать число Пи в виде константы 3.14 и две функции, 
которые будут считать площадь круга и прямоугольника.
Второй модуль должен импортировать первый, далее запрашивать у 
пользователя размеры круга и квадрата. В результате выводить, какая 
из фигур больше.

Ответ:
PI = 3.14

def circle_area(r):
   return PI * (r ** 2)


def rect_area(a, b):
   return a * b


if __name__ == '__main__':
   # проверяем работоспособность функции, дальнейшая часть не будет импортирована
   assert circle_area(5) == 78.5  # если ответы будут отличаться, то будет вызвана ошибка
   assert rect_area(5, 4) == 20
from module_name import *

def main():
r = int(input('Введите радиус круга:\n'))

a = int(input('Введите длину прямоугольника:\n'))
b = int(input('Введите ширину прямоугольника:\n'))
if circle_area(r) > rect_area(a, b):
print('Площадь круга больше')
else:
print('Площадь прямоугольника больше')

if name == 'main':
main()
Вопрос 1: верно
